import In, { useState as Ne } from "react";
import I, { css as Ue } from "styled-components";
var Q = { exports: {} }, B = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Fe;
function Cn() {
  if (Fe) return B;
  Fe = 1;
  var e = Symbol.for("react.transitional.element"), n = Symbol.for("react.fragment");
  function t(r, o, i) {
    var s = null;
    if (i !== void 0 && (s = "" + i), o.key !== void 0 && (s = "" + o.key), "key" in o) {
      i = {};
      for (var u in o)
        u !== "key" && (i[u] = o[u]);
    } else i = o;
    return o = i.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: o !== void 0 ? o : null,
      props: i
    };
  }
  return B.Fragment = n, B.jsx = t, B.jsxs = t, B;
}
var q = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Le;
function Dn() {
  return Le || (Le = 1, process.env.NODE_ENV !== "production" && (function() {
    function e(a) {
      if (a == null) return null;
      if (typeof a == "function")
        return a.$$typeof === An ? null : a.displayName || a.name || null;
      if (typeof a == "string") return a;
      switch (a) {
        case Y:
          return "Fragment";
        case he:
          return "Profiler";
        case H:
          return "StrictMode";
        case U:
          return "Suspense";
        case On:
          return "SuspenseList";
        case Rn:
          return "Activity";
      }
      if (typeof a == "object")
        switch (typeof a.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), a.$$typeof) {
          case T:
            return "Portal";
          case R:
            return (a.displayName || "Context") + ".Provider";
          case me:
            return (a._context.displayName || "Context") + ".Consumer";
          case O:
            var p = a.render;
            return a = a.displayName, a || (a = p.displayName || p.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case jn:
            return p = a.displayName || null, p !== null ? p : e(a.type) || "Memo";
          case Re:
            p = a._payload, a = a._init;
            try {
              return e(a(p));
            } catch {
            }
        }
      return null;
    }
    function n(a) {
      return "" + a;
    }
    function t(a) {
      try {
        n(a);
        var p = !1;
      } catch {
        p = !0;
      }
      if (p) {
        p = console;
        var w = p.error, Z = typeof Symbol == "function" && Symbol.toStringTag && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return w.call(
          p,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          Z
        ), n(a);
      }
    }
    function r(a) {
      if (a === Y) return "<>";
      if (typeof a == "object" && a !== null && a.$$typeof === Re)
        return "<...>";
      try {
        var p = e(a);
        return p ? "<" + p + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function o() {
      var a = _e.A;
      return a === null ? null : a.getOwner();
    }
    function i() {
      return Error("react-stack-top-frame");
    }
    function s(a) {
      if (Ae.call(a, "key")) {
        var p = Object.getOwnPropertyDescriptor(a, "key").get;
        if (p && p.isReactWarning) return !1;
      }
      return a.key !== void 0;
    }
    function u(a, p) {
      function w() {
        Se || (Se = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          p
        ));
      }
      w.isReactWarning = !0, Object.defineProperty(a, "key", {
        get: w,
        configurable: !0
      });
    }
    function d() {
      var a = e(this.type);
      return xe[a] || (xe[a] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), a = this.props.ref, a !== void 0 ? a : null;
    }
    function l(a, p, w, Z, C, A, ve, we) {
      return w = A.ref, a = {
        $$typeof: _,
        type: a,
        key: p,
        props: A,
        _owner: C
      }, (w !== void 0 ? w : null) !== null ? Object.defineProperty(a, "ref", {
        enumerable: !1,
        get: d
      }) : Object.defineProperty(a, "ref", { enumerable: !1, value: null }), a._store = {}, Object.defineProperty(a._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(a, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(a, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ve
      }), Object.defineProperty(a, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: we
      }), Object.freeze && (Object.freeze(a.props), Object.freeze(a)), a;
    }
    function h(a, p, w, Z, C, A, ve, we) {
      var y = p.children;
      if (y !== void 0)
        if (Z)
          if (Sn(y)) {
            for (Z = 0; Z < y.length; Z++)
              z(y[Z]);
            Object.freeze && Object.freeze(y);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else z(y);
      if (Ae.call(p, "key")) {
        y = e(a);
        var M = Object.keys(p).filter(function(xn) {
          return xn !== "key";
        });
        Z = 0 < M.length ? "{key: someKey, " + M.join(": ..., ") + ": ...}" : "{key: someKey}", De[y + Z] || (M = 0 < M.length ? "{" + M.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          Z,
          y,
          M,
          y
        ), De[y + Z] = !0);
      }
      if (y = null, w !== void 0 && (t(w), y = "" + w), s(p) && (t(p.key), y = "" + p.key), "key" in p) {
        w = {};
        for (var be in p)
          be !== "key" && (w[be] = p[be]);
      } else w = p;
      return y && u(
        w,
        typeof a == "function" ? a.displayName || a.name || "Unknown" : a
      ), l(
        a,
        y,
        A,
        C,
        o(),
        w,
        ve,
        we
      );
    }
    function z(a) {
      typeof a == "object" && a !== null && a.$$typeof === _ && a._store && (a._store.validated = 1);
    }
    var v = In, _ = Symbol.for("react.transitional.element"), T = Symbol.for("react.portal"), Y = Symbol.for("react.fragment"), H = Symbol.for("react.strict_mode"), he = Symbol.for("react.profiler"), me = Symbol.for("react.consumer"), R = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), On = Symbol.for("react.suspense_list"), jn = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), Rn = Symbol.for("react.activity"), An = Symbol.for("react.client.reference"), _e = v.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ae = Object.prototype.hasOwnProperty, Sn = Array.isArray, ge = console.createTask ? console.createTask : function() {
      return null;
    };
    v = {
      react_stack_bottom_frame: function(a) {
        return a();
      }
    };
    var Se, xe = {}, Ie = v.react_stack_bottom_frame.bind(
      v,
      i
    )(), Ce = ge(r(i)), De = {};
    q.Fragment = Y, q.jsx = function(a, p, w, Z, C) {
      var A = 1e4 > _e.recentlyCreatedOwnerStacks++;
      return h(
        a,
        p,
        w,
        !1,
        Z,
        C,
        A ? Error("react-stack-top-frame") : Ie,
        A ? ge(r(a)) : Ce
      );
    }, q.jsxs = function(a, p, w, Z, C) {
      var A = 1e4 > _e.recentlyCreatedOwnerStacks++;
      return h(
        a,
        p,
        w,
        !0,
        Z,
        C,
        A ? Error("react-stack-top-frame") : Ie,
        A ? ge(r(a)) : Ce
      );
    };
  })()), q;
}
var Me;
function Nn() {
  return Me || (Me = 1, process.env.NODE_ENV === "production" ? Q.exports = Cn() : Q.exports = Dn()), Q.exports;
}
var P = Nn();
const x = {
  colors: {
    white: "#fffaf1",
    black: "#1c1c1c"
  }
}, Un = I.button`
  width: fit-content;
  padding: 10px 20px;
  background: ${x.colors.black};
  border: 1px solid ${x.colors.white};
  border-radius: 4px;
  color: ${x.colors.white};
  cursor: pointer;
`, Fn = ({
  text: e,
  variant: n,
  href: t,
  onClick: r,
  className: o,
  ...i
}) => /* @__PURE__ */ P.jsx(Un, { ...i, onClick: r, className: o, children: e }), Ln = I.div`
  ${({ $index: e, $animationConfig: n, $animationGap: t, $itemDefaultValues: r }) => {
  const {
    keyframes: o,
    delay: i = 0,
    direction: s = "normal",
    duration: u = 300,
    iterationCount: d = 1,
    timingFunction: l = "ease",
    fillMode: h = "forwards"
  } = n, z = i + e * t;
  return Ue`
      /* Inject default values */
      ${r && Ue({
    ...r
  })}

      /* Animation config */
      animation-name: ${o};
      animation-duration: ${u}ms;
      animation-delay: ${z}ms;
      animation-direction: ${s};
      animation-iteration-count: ${d};
      animation-timing-function: ${l};
      animation-fill-mode: ${h};
    `;
}}
`, Xs = ({
  itemIndex: e,
  item: n,
  itemDefaultCssValues: t,
  animationConfig: r,
  animationGap: o = 0
}) => /* @__PURE__ */ P.jsx(
  Ln,
  {
    $index: e,
    $itemDefaultValues: t,
    $animationConfig: r,
    $animationGap: o,
    children: n
  }
), Mn = I.div`
  display: flex;
  flex-direction: column;
  align-items: start;
  width: 100%;
`, Wn = I.label`
  color: ${x.colors.white};
  font-size: 14px;
`, Vn = I.input`
  background: ${x.colors.black};
  color: ${x.colors.white};
  border: 1px solid ${x.colors.white};
  padding: 5px;
  width: 100%;
  margin: 4px 0;

  &::placeholder {
    color: ${x.colors.white};
  }
`, Jn = I.span`
  color: #ff4d4f;
  font-size: 14px;
`, ee = ({
  name: e,
  label: n,
  placeholder: t,
  errorMessage: r,
  onChange: o,
  ...i
}) => /* @__PURE__ */ P.jsxs(Mn, { children: [
  /* @__PURE__ */ P.jsx(Wn, { children: n }),
  /* @__PURE__ */ P.jsx(
    Vn,
    {
      ...i,
      name: e,
      placeholder: t,
      onChange: o
    }
  ),
  r && /* @__PURE__ */ P.jsx(Jn, { children: r })
] });
var an = /* @__PURE__ */ ((e) => (e.FullName = "full-name", e.UserName = "user-name", e.All = "all", e))(an || {}), E = /* @__PURE__ */ ((e) => (e.firstName = "firstName", e.lastName = "lastName", e.password = "password", e.passwordCheck = "passwordCheck", e))(E || {});
const Yn = I.form`
  border: 1px solid ${x.colors.white};
  padding: 10px;
  border-radius: 10px;
`, We = I.div`
  display: flex;
  width: 100%;
  gap: 0 8px;
`, Bn = I(Fn)`
  margin-top: 4px;
`, ne = ({ e, setState: n }) => {
  const { name: t, value: r } = e.target;
  n((o) => ({ ...o, [t]: r }));
};
function c(e, n, t) {
  function r(u, d) {
    var l;
    Object.defineProperty(u, "_zod", {
      value: u._zod ?? {},
      enumerable: !1
    }), (l = u._zod).traits ?? (l.traits = /* @__PURE__ */ new Set()), u._zod.traits.add(e), n(u, d);
    for (const h in s.prototype)
      h in u || Object.defineProperty(u, h, { value: s.prototype[h].bind(u) });
    u._zod.constr = s, u._zod.def = d;
  }
  const o = t?.Parent ?? Object;
  class i extends o {
  }
  Object.defineProperty(i, "name", { value: e });
  function s(u) {
    var d;
    const l = t?.Parent ? new i() : this;
    r(l, u), (d = l._zod).deferred ?? (d.deferred = []);
    for (const h of l._zod.deferred)
      h();
    return l;
  }
  return Object.defineProperty(s, "init", { value: r }), Object.defineProperty(s, Symbol.hasInstance, {
    value: (u) => t?.Parent && u instanceof t.Parent ? !0 : u?._zod?.traits?.has(e)
  }), Object.defineProperty(s, "name", { value: e }), s;
}
class V extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class un extends Error {
  constructor(n) {
    super(`Encountered unidirectional transform during encode: ${n}`), this.name = "ZodEncodeError";
  }
}
const ln = {};
function F(e) {
  return ln;
}
function qn(e) {
  const n = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, o]) => n.indexOf(+r) === -1).map(([r, o]) => o);
}
function ze(e, n) {
  return typeof n == "bigint" ? n.toString() : n;
}
function Ze(e) {
  return {
    get value() {
      {
        const n = e();
        return Object.defineProperty(this, "value", { value: n }), n;
      }
    }
  };
}
function ye(e) {
  return e == null;
}
function Ee(e) {
  const n = e.startsWith("^") ? 1 : 0, t = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(n, t);
}
const Ve = Symbol("evaluating");
function m(e, n, t) {
  let r;
  Object.defineProperty(e, n, {
    get() {
      if (r !== Ve)
        return r === void 0 && (r = Ve, r = t()), r;
    },
    set(o) {
      Object.defineProperty(e, n, {
        value: o
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Gn(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function D(e, n, t) {
  Object.defineProperty(e, n, {
    value: t,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function J(...e) {
  const n = {};
  for (const t of e) {
    const r = Object.getOwnPropertyDescriptors(t);
    Object.assign(n, r);
  }
  return Object.defineProperties({}, n);
}
function Je(e) {
  return JSON.stringify(e);
}
const dn = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function ce(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const Kn = Ze(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function G(e) {
  if (ce(e) === !1)
    return !1;
  const n = e.constructor;
  if (n === void 0)
    return !0;
  const t = n.prototype;
  return !(ce(t) === !1 || Object.prototype.hasOwnProperty.call(t, "isPrototypeOf") === !1);
}
function fn(e) {
  return G(e) ? { ...e } : e;
}
const Xn = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function le(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function N(e, n, t) {
  const r = new e._zod.constr(n ?? e._zod.def);
  return (!n || t?.parent) && (r._zod.parent = e), r;
}
function f(e) {
  const n = e;
  if (!n)
    return {};
  if (typeof n == "string")
    return { error: () => n };
  if (n?.message !== void 0) {
    if (n?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    n.error = n.message;
  }
  return delete n.message, typeof n.error == "string" ? { ...n, error: () => n.error } : n;
}
function Hn(e) {
  return Object.keys(e).filter((n) => e[n]._zod.optin === "optional" && e[n]._zod.optout === "optional");
}
function Qn(e, n) {
  const t = e._zod.def, r = J(e._zod.def, {
    get shape() {
      const o = {};
      for (const i in n) {
        if (!(i in t.shape))
          throw new Error(`Unrecognized key: "${i}"`);
        n[i] && (o[i] = t.shape[i]);
      }
      return D(this, "shape", o), o;
    },
    checks: []
  });
  return N(e, r);
}
function et(e, n) {
  const t = e._zod.def, r = J(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape };
      for (const i in n) {
        if (!(i in t.shape))
          throw new Error(`Unrecognized key: "${i}"`);
        n[i] && delete o[i];
      }
      return D(this, "shape", o), o;
    },
    checks: []
  });
  return N(e, r);
}
function nt(e, n) {
  if (!G(n))
    throw new Error("Invalid input to extend: expected a plain object");
  const t = e._zod.def.checks;
  if (t && t.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const o = J(e._zod.def, {
    get shape() {
      const i = { ...e._zod.def.shape, ...n };
      return D(this, "shape", i), i;
    },
    checks: []
  });
  return N(e, o);
}
function tt(e, n) {
  if (!G(n))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const t = {
    ...e._zod.def,
    get shape() {
      const r = { ...e._zod.def.shape, ...n };
      return D(this, "shape", r), r;
    },
    checks: e._zod.def.checks
  };
  return N(e, t);
}
function rt(e, n) {
  const t = J(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...n._zod.def.shape };
      return D(this, "shape", r), r;
    },
    get catchall() {
      return n._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return N(e, t);
}
function ot(e, n, t) {
  const r = J(n._zod.def, {
    get shape() {
      const o = n._zod.def.shape, i = { ...o };
      if (t)
        for (const s in t) {
          if (!(s in o))
            throw new Error(`Unrecognized key: "${s}"`);
          t[s] && (i[s] = e ? new e({
            type: "optional",
            innerType: o[s]
          }) : o[s]);
        }
      else
        for (const s in o)
          i[s] = e ? new e({
            type: "optional",
            innerType: o[s]
          }) : o[s];
      return D(this, "shape", i), i;
    },
    checks: []
  });
  return N(n, r);
}
function st(e, n, t) {
  const r = J(n._zod.def, {
    get shape() {
      const o = n._zod.def.shape, i = { ...o };
      if (t)
        for (const s in t) {
          if (!(s in i))
            throw new Error(`Unrecognized key: "${s}"`);
          t[s] && (i[s] = new e({
            type: "nonoptional",
            innerType: o[s]
          }));
        }
      else
        for (const s in o)
          i[s] = new e({
            type: "nonoptional",
            innerType: o[s]
          });
      return D(this, "shape", i), i;
    },
    checks: []
  });
  return N(n, r);
}
function W(e, n = 0) {
  if (e.aborted === !0)
    return !0;
  for (let t = n; t < e.issues.length; t++)
    if (e.issues[t]?.continue !== !0)
      return !0;
  return !1;
}
function pn(e, n) {
  return n.map((t) => {
    var r;
    return (r = t).path ?? (r.path = []), t.path.unshift(e), t;
  });
}
function te(e) {
  return typeof e == "string" ? e : e?.message;
}
function L(e, n, t) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const o = te(e.inst?._zod.def?.error?.(e)) ?? te(n?.error?.(e)) ?? te(t.customError?.(e)) ?? te(t.localeError?.(e)) ?? "Invalid input";
    r.message = o;
  }
  return delete r.inst, delete r.continue, n?.reportInput || delete r.input, r;
}
function Pe(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function K(...e) {
  const [n, t, r] = e;
  return typeof n == "string" ? {
    message: n,
    code: "custom",
    input: t,
    inst: r
  } : { ...n };
}
const hn = (e, n) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: n,
    enumerable: !1
  }), e.message = JSON.stringify(n, ze, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, mn = c("$ZodError", hn), _n = c("$ZodError", hn, { Parent: Error });
function gn(e, n = (t) => t.message) {
  const t = {}, r = [];
  for (const o of e.issues)
    o.path.length > 0 ? (t[o.path[0]] = t[o.path[0]] || [], t[o.path[0]].push(n(o))) : r.push(n(o));
  return { formErrors: r, fieldErrors: t };
}
function it(e, n) {
  const t = n || function(i) {
    return i.message;
  }, r = { _errors: [] }, o = (i) => {
    for (const s of i.issues)
      if (s.code === "invalid_union" && s.errors.length)
        s.errors.map((u) => o({ issues: u }));
      else if (s.code === "invalid_key")
        o({ issues: s.issues });
      else if (s.code === "invalid_element")
        o({ issues: s.issues });
      else if (s.path.length === 0)
        r._errors.push(t(s));
      else {
        let u = r, d = 0;
        for (; d < s.path.length; ) {
          const l = s.path[d];
          d === s.path.length - 1 ? (u[l] = u[l] || { _errors: [] }, u[l]._errors.push(t(s))) : u[l] = u[l] || { _errors: [] }, u = u[l], d++;
        }
      }
  };
  return o(e), r;
}
const Te = (e) => (n, t, r, o) => {
  const i = r ? Object.assign(r, { async: !1 }) : { async: !1 }, s = n._zod.run({ value: t, issues: [] }, i);
  if (s instanceof Promise)
    throw new V();
  if (s.issues.length) {
    const u = new (o?.Err ?? e)(s.issues.map((d) => L(d, i, F())));
    throw dn(u, o?.callee), u;
  }
  return s.value;
}, Oe = (e) => async (n, t, r, o) => {
  const i = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = n._zod.run({ value: t, issues: [] }, i);
  if (s instanceof Promise && (s = await s), s.issues.length) {
    const u = new (o?.Err ?? e)(s.issues.map((d) => L(d, i, F())));
    throw dn(u, o?.callee), u;
  }
  return s.value;
}, de = (e) => (n, t, r) => {
  const o = r ? { ...r, async: !1 } : { async: !1 }, i = n._zod.run({ value: t, issues: [] }, o);
  if (i instanceof Promise)
    throw new V();
  return i.issues.length ? {
    success: !1,
    error: new (e ?? mn)(i.issues.map((s) => L(s, o, F())))
  } : { success: !0, data: i.value };
}, ct = /* @__PURE__ */ de(_n), fe = (e) => async (n, t, r) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let i = n._zod.run({ value: t, issues: [] }, o);
  return i instanceof Promise && (i = await i), i.issues.length ? {
    success: !1,
    error: new e(i.issues.map((s) => L(s, o, F())))
  } : { success: !0, data: i.value };
}, at = /* @__PURE__ */ fe(_n), ut = (e) => (n, t, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Te(e)(n, t, o);
}, lt = (e) => (n, t, r) => Te(e)(n, t, r), dt = (e) => async (n, t, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Oe(e)(n, t, o);
}, ft = (e) => async (n, t, r) => Oe(e)(n, t, r), pt = (e) => (n, t, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return de(e)(n, t, o);
}, ht = (e) => (n, t, r) => de(e)(n, t, r), mt = (e) => async (n, t, r) => {
  const o = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return fe(e)(n, t, o);
}, _t = (e) => async (n, t, r) => fe(e)(n, t, r), gt = /^[cC][^\s-]{8,}$/, vt = /^[0-9a-z]+$/, wt = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, bt = /^[0-9a-vA-V]{20}$/, zt = /^[A-Za-z0-9]{27}$/, kt = /^[a-zA-Z0-9_-]{21}$/, $t = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Zt = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, Ye = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, yt = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Et = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Pt() {
  return new RegExp(Et, "u");
}
const Tt = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ot = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, jt = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Rt = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, At = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, vn = /^[A-Za-z0-9_-]*$/, St = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, xt = /^\+(?:[0-9]){6,14}[0-9]$/, wn = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", It = /* @__PURE__ */ new RegExp(`^${wn}$`);
function bn(e) {
  const n = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${n}` : e.precision === 0 ? `${n}:[0-5]\\d` : `${n}:[0-5]\\d\\.\\d{${e.precision}}` : `${n}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Ct(e) {
  return new RegExp(`^${bn(e)}$`);
}
function Dt(e) {
  const n = bn({ precision: e.precision }), t = ["Z"];
  e.local && t.push(""), e.offset && t.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${n}(?:${t.join("|")})`;
  return new RegExp(`^${wn}T(?:${r})$`);
}
const Nt = (e) => {
  const n = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${n}$`);
}, Ut = /^[^A-Z]*$/, Ft = /^[^a-z]*$/, S = /* @__PURE__ */ c("$ZodCheck", (e, n) => {
  var t;
  e._zod ?? (e._zod = {}), e._zod.def = n, (t = e._zod).onattach ?? (t.onattach = []);
}), Lt = /* @__PURE__ */ c("$ZodCheckMaxLength", (e, n) => {
  var t;
  S.init(e, n), (t = e._zod.def).when ?? (t.when = (r) => {
    const o = r.value;
    return !ye(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    n.maximum < o && (r._zod.bag.maximum = n.maximum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length <= n.maximum)
      return;
    const s = Pe(o);
    r.issues.push({
      origin: s,
      code: "too_big",
      maximum: n.maximum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !n.abort
    });
  };
}), Mt = /* @__PURE__ */ c("$ZodCheckMinLength", (e, n) => {
  var t;
  S.init(e, n), (t = e._zod.def).when ?? (t.when = (r) => {
    const o = r.value;
    return !ye(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    n.minimum > o && (r._zod.bag.minimum = n.minimum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length >= n.minimum)
      return;
    const s = Pe(o);
    r.issues.push({
      origin: s,
      code: "too_small",
      minimum: n.minimum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !n.abort
    });
  };
}), Wt = /* @__PURE__ */ c("$ZodCheckLengthEquals", (e, n) => {
  var t;
  S.init(e, n), (t = e._zod.def).when ?? (t.when = (r) => {
    const o = r.value;
    return !ye(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.minimum = n.length, o.maximum = n.length, o.length = n.length;
  }), e._zod.check = (r) => {
    const o = r.value, i = o.length;
    if (i === n.length)
      return;
    const s = Pe(o), u = i > n.length;
    r.issues.push({
      origin: s,
      ...u ? { code: "too_big", maximum: n.length } : { code: "too_small", minimum: n.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !n.abort
    });
  };
}), pe = /* @__PURE__ */ c("$ZodCheckStringFormat", (e, n) => {
  var t, r;
  S.init(e, n), e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.format = n.format, n.pattern && (i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n.pattern));
  }), n.pattern ? (t = e._zod).check ?? (t.check = (o) => {
    n.pattern.lastIndex = 0, !n.pattern.test(o.value) && o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: n.format,
      input: o.value,
      ...n.pattern ? { pattern: n.pattern.toString() } : {},
      inst: e,
      continue: !n.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), Vt = /* @__PURE__ */ c("$ZodCheckRegex", (e, n) => {
  pe.init(e, n), e._zod.check = (t) => {
    n.pattern.lastIndex = 0, !n.pattern.test(t.value) && t.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: t.value,
      pattern: n.pattern.toString(),
      inst: e,
      continue: !n.abort
    });
  };
}), Jt = /* @__PURE__ */ c("$ZodCheckLowerCase", (e, n) => {
  n.pattern ?? (n.pattern = Ut), pe.init(e, n);
}), Yt = /* @__PURE__ */ c("$ZodCheckUpperCase", (e, n) => {
  n.pattern ?? (n.pattern = Ft), pe.init(e, n);
}), Bt = /* @__PURE__ */ c("$ZodCheckIncludes", (e, n) => {
  S.init(e, n);
  const t = le(n.includes), r = new RegExp(typeof n.position == "number" ? `^.{${n.position}}${t}` : t);
  n.pattern = r, e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(r);
  }), e._zod.check = (o) => {
    o.value.includes(n.includes, n.position) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: n.includes,
      input: o.value,
      inst: e,
      continue: !n.abort
    });
  };
}), qt = /* @__PURE__ */ c("$ZodCheckStartsWith", (e, n) => {
  S.init(e, n);
  const t = new RegExp(`^${le(n.prefix)}.*`);
  n.pattern ?? (n.pattern = t), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t);
  }), e._zod.check = (r) => {
    r.value.startsWith(n.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: n.prefix,
      input: r.value,
      inst: e,
      continue: !n.abort
    });
  };
}), Gt = /* @__PURE__ */ c("$ZodCheckEndsWith", (e, n) => {
  S.init(e, n);
  const t = new RegExp(`.*${le(n.suffix)}$`);
  n.pattern ?? (n.pattern = t), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t);
  }), e._zod.check = (r) => {
    r.value.endsWith(n.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: n.suffix,
      input: r.value,
      inst: e,
      continue: !n.abort
    });
  };
}), Kt = /* @__PURE__ */ c("$ZodCheckOverwrite", (e, n) => {
  S.init(e, n), e._zod.check = (t) => {
    t.value = n.tx(t.value);
  };
});
class Xt {
  constructor(n = []) {
    this.content = [], this.indent = 0, this && (this.args = n);
  }
  indented(n) {
    this.indent += 1, n(this), this.indent -= 1;
  }
  write(n) {
    if (typeof n == "function") {
      n(this, { execution: "sync" }), n(this, { execution: "async" });
      return;
    }
    const r = n.split(`
`).filter((s) => s), o = Math.min(...r.map((s) => s.length - s.trimStart().length)), i = r.map((s) => s.slice(o)).map((s) => " ".repeat(this.indent * 2) + s);
    for (const s of i)
      this.content.push(s);
  }
  compile() {
    const n = Function, t = this?.args, o = [...(this?.content ?? [""]).map((i) => `  ${i}`)];
    return new n(...t, o.join(`
`));
  }
}
const Ht = {
  major: 4,
  minor: 1,
  patch: 5
}, k = /* @__PURE__ */ c("$ZodType", (e, n) => {
  var t;
  e ?? (e = {}), e._zod.def = n, e._zod.bag = e._zod.bag || {}, e._zod.version = Ht;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const o of r)
    for (const i of o._zod.onattach)
      i(e);
  if (r.length === 0)
    (t = e._zod).deferred ?? (t.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const o = (s, u, d) => {
      let l = W(s), h;
      for (const z of u) {
        if (z._zod.def.when) {
          if (!z._zod.def.when(s))
            continue;
        } else if (l)
          continue;
        const v = s.issues.length, _ = z._zod.check(s);
        if (_ instanceof Promise && d?.async === !1)
          throw new V();
        if (h || _ instanceof Promise)
          h = (h ?? Promise.resolve()).then(async () => {
            await _, s.issues.length !== v && (l || (l = W(s, v)));
          });
        else {
          if (s.issues.length === v)
            continue;
          l || (l = W(s, v));
        }
      }
      return h ? h.then(() => s) : s;
    }, i = (s, u, d) => {
      if (W(s))
        return s.aborted = !0, s;
      const l = o(u, r, d);
      if (l instanceof Promise) {
        if (d.async === !1)
          throw new V();
        return l.then((h) => e._zod.parse(h, d));
      }
      return e._zod.parse(l, d);
    };
    e._zod.run = (s, u) => {
      if (u.skipChecks)
        return e._zod.parse(s, u);
      if (u.direction === "backward") {
        const l = e._zod.parse({ value: s.value, issues: [] }, { ...u, skipChecks: !0 });
        return l instanceof Promise ? l.then((h) => i(h, s, u)) : i(l, s, u);
      }
      const d = e._zod.parse(s, u);
      if (d instanceof Promise) {
        if (u.async === !1)
          throw new V();
        return d.then((l) => o(l, r, u));
      }
      return o(d, r, u);
    };
  }
  e["~standard"] = {
    validate: (o) => {
      try {
        const i = ct(e, o);
        return i.success ? { value: i.data } : { issues: i.error?.issues };
      } catch {
        return at(e, o).then((s) => s.success ? { value: s.data } : { issues: s.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), je = /* @__PURE__ */ c("$ZodString", (e, n) => {
  k.init(e, n), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? Nt(e._zod.bag), e._zod.parse = (t, r) => {
    if (n.coerce)
      try {
        t.value = String(t.value);
      } catch {
      }
    return typeof t.value == "string" || t.issues.push({
      expected: "string",
      code: "invalid_type",
      input: t.value,
      inst: e
    }), t;
  };
}), g = /* @__PURE__ */ c("$ZodStringFormat", (e, n) => {
  pe.init(e, n), je.init(e, n);
}), Qt = /* @__PURE__ */ c("$ZodGUID", (e, n) => {
  n.pattern ?? (n.pattern = Zt), g.init(e, n);
}), er = /* @__PURE__ */ c("$ZodUUID", (e, n) => {
  if (n.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[n.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${n.version}"`);
    n.pattern ?? (n.pattern = Ye(r));
  } else
    n.pattern ?? (n.pattern = Ye());
  g.init(e, n);
}), nr = /* @__PURE__ */ c("$ZodEmail", (e, n) => {
  n.pattern ?? (n.pattern = yt), g.init(e, n);
}), tr = /* @__PURE__ */ c("$ZodURL", (e, n) => {
  g.init(e, n), e._zod.check = (t) => {
    try {
      const r = t.value.trim(), o = new URL(r);
      n.hostname && (n.hostname.lastIndex = 0, n.hostname.test(o.hostname) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: St.source,
        input: t.value,
        inst: e,
        continue: !n.abort
      })), n.protocol && (n.protocol.lastIndex = 0, n.protocol.test(o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol) || t.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: n.protocol.source,
        input: t.value,
        inst: e,
        continue: !n.abort
      })), n.normalize ? t.value = o.href : t.value = r;
      return;
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "url",
        input: t.value,
        inst: e,
        continue: !n.abort
      });
    }
  };
}), rr = /* @__PURE__ */ c("$ZodEmoji", (e, n) => {
  n.pattern ?? (n.pattern = Pt()), g.init(e, n);
}), or = /* @__PURE__ */ c("$ZodNanoID", (e, n) => {
  n.pattern ?? (n.pattern = kt), g.init(e, n);
}), sr = /* @__PURE__ */ c("$ZodCUID", (e, n) => {
  n.pattern ?? (n.pattern = gt), g.init(e, n);
}), ir = /* @__PURE__ */ c("$ZodCUID2", (e, n) => {
  n.pattern ?? (n.pattern = vt), g.init(e, n);
}), cr = /* @__PURE__ */ c("$ZodULID", (e, n) => {
  n.pattern ?? (n.pattern = wt), g.init(e, n);
}), ar = /* @__PURE__ */ c("$ZodXID", (e, n) => {
  n.pattern ?? (n.pattern = bt), g.init(e, n);
}), ur = /* @__PURE__ */ c("$ZodKSUID", (e, n) => {
  n.pattern ?? (n.pattern = zt), g.init(e, n);
}), lr = /* @__PURE__ */ c("$ZodISODateTime", (e, n) => {
  n.pattern ?? (n.pattern = Dt(n)), g.init(e, n);
}), dr = /* @__PURE__ */ c("$ZodISODate", (e, n) => {
  n.pattern ?? (n.pattern = It), g.init(e, n);
}), fr = /* @__PURE__ */ c("$ZodISOTime", (e, n) => {
  n.pattern ?? (n.pattern = Ct(n)), g.init(e, n);
}), pr = /* @__PURE__ */ c("$ZodISODuration", (e, n) => {
  n.pattern ?? (n.pattern = $t), g.init(e, n);
}), hr = /* @__PURE__ */ c("$ZodIPv4", (e, n) => {
  n.pattern ?? (n.pattern = Tt), g.init(e, n), e._zod.onattach.push((t) => {
    const r = t._zod.bag;
    r.format = "ipv4";
  });
}), mr = /* @__PURE__ */ c("$ZodIPv6", (e, n) => {
  n.pattern ?? (n.pattern = Ot), g.init(e, n), e._zod.onattach.push((t) => {
    const r = t._zod.bag;
    r.format = "ipv6";
  }), e._zod.check = (t) => {
    try {
      new URL(`http://[${t.value}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: t.value,
        inst: e,
        continue: !n.abort
      });
    }
  };
}), _r = /* @__PURE__ */ c("$ZodCIDRv4", (e, n) => {
  n.pattern ?? (n.pattern = jt), g.init(e, n);
}), gr = /* @__PURE__ */ c("$ZodCIDRv6", (e, n) => {
  n.pattern ?? (n.pattern = Rt), g.init(e, n), e._zod.check = (t) => {
    const [r, o] = t.value.split("/");
    try {
      if (!o)
        throw new Error();
      const i = Number(o);
      if (`${i}` !== o)
        throw new Error();
      if (i < 0 || i > 128)
        throw new Error();
      new URL(`http://[${r}]`);
    } catch {
      t.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: t.value,
        inst: e,
        continue: !n.abort
      });
    }
  };
});
function zn(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const vr = /* @__PURE__ */ c("$ZodBase64", (e, n) => {
  n.pattern ?? (n.pattern = At), g.init(e, n), e._zod.onattach.push((t) => {
    t._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (t) => {
    zn(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64",
      input: t.value,
      inst: e,
      continue: !n.abort
    });
  };
});
function wr(e) {
  if (!vn.test(e))
    return !1;
  const n = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), t = n.padEnd(Math.ceil(n.length / 4) * 4, "=");
  return zn(t);
}
const br = /* @__PURE__ */ c("$ZodBase64URL", (e, n) => {
  n.pattern ?? (n.pattern = vn), g.init(e, n), e._zod.onattach.push((t) => {
    t._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (t) => {
    wr(t.value) || t.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: t.value,
      inst: e,
      continue: !n.abort
    });
  };
}), zr = /* @__PURE__ */ c("$ZodE164", (e, n) => {
  n.pattern ?? (n.pattern = xt), g.init(e, n);
});
function kr(e, n = null) {
  try {
    const t = e.split(".");
    if (t.length !== 3)
      return !1;
    const [r] = t;
    if (!r)
      return !1;
    const o = JSON.parse(atob(r));
    return !("typ" in o && o?.typ !== "JWT" || !o.alg || n && (!("alg" in o) || o.alg !== n));
  } catch {
    return !1;
  }
}
const $r = /* @__PURE__ */ c("$ZodJWT", (e, n) => {
  g.init(e, n), e._zod.check = (t) => {
    kr(t.value, n.alg) || t.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: t.value,
      inst: e,
      continue: !n.abort
    });
  };
}), Zr = /* @__PURE__ */ c("$ZodUnknown", (e, n) => {
  k.init(e, n), e._zod.parse = (t) => t;
}), yr = /* @__PURE__ */ c("$ZodNever", (e, n) => {
  k.init(e, n), e._zod.parse = (t, r) => (t.issues.push({
    expected: "never",
    code: "invalid_type",
    input: t.value,
    inst: e
  }), t);
});
function Be(e, n, t) {
  e.issues.length && n.issues.push(...pn(t, e.issues)), n.value[t] = e.value;
}
const Er = /* @__PURE__ */ c("$ZodArray", (e, n) => {
  k.init(e, n), e._zod.parse = (t, r) => {
    const o = t.value;
    if (!Array.isArray(o))
      return t.issues.push({
        expected: "array",
        code: "invalid_type",
        input: o,
        inst: e
      }), t;
    t.value = Array(o.length);
    const i = [];
    for (let s = 0; s < o.length; s++) {
      const u = o[s], d = n.element._zod.run({
        value: u,
        issues: []
      }, r);
      d instanceof Promise ? i.push(d.then((l) => Be(l, t, s))) : Be(d, t, s);
    }
    return i.length ? Promise.all(i).then(() => t) : t;
  };
});
function ae(e, n, t, r) {
  e.issues.length && n.issues.push(...pn(t, e.issues)), e.value === void 0 ? t in r && (n.value[t] = void 0) : n.value[t] = e.value;
}
function kn(e) {
  const n = Object.keys(e.shape);
  for (const r of n)
    if (!e.shape[r]._zod.traits.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const t = Hn(e.shape);
  return {
    ...e,
    keys: n,
    keySet: new Set(n),
    numKeys: n.length,
    optionalKeys: new Set(t)
  };
}
function $n(e, n, t, r, o, i) {
  const s = [], u = o.keySet, d = o.catchall._zod, l = d.def.type;
  for (const h of Object.keys(n)) {
    if (u.has(h))
      continue;
    if (l === "never") {
      s.push(h);
      continue;
    }
    const z = d.run({ value: n[h], issues: [] }, r);
    z instanceof Promise ? e.push(z.then((v) => ae(v, t, h, n))) : ae(z, t, h, n);
  }
  return s.length && t.issues.push({
    code: "unrecognized_keys",
    keys: s,
    input: n,
    inst: i
  }), e.length ? Promise.all(e).then(() => t) : t;
}
const Pr = /* @__PURE__ */ c("$ZodObject", (e, n) => {
  k.init(e, n);
  const t = Ze(() => kn(n));
  m(e._zod, "propValues", () => {
    const s = n.shape, u = {};
    for (const d in s) {
      const l = s[d]._zod;
      if (l.values) {
        u[d] ?? (u[d] = /* @__PURE__ */ new Set());
        for (const h of l.values)
          u[d].add(h);
      }
    }
    return u;
  });
  const r = ce, o = n.catchall;
  let i;
  e._zod.parse = (s, u) => {
    i ?? (i = t.value);
    const d = s.value;
    if (!r(d))
      return s.issues.push({
        expected: "object",
        code: "invalid_type",
        input: d,
        inst: e
      }), s;
    s.value = {};
    const l = [], h = i.shape;
    for (const z of i.keys) {
      const _ = h[z]._zod.run({ value: d[z], issues: [] }, u);
      _ instanceof Promise ? l.push(_.then((T) => ae(T, s, z, d))) : ae(_, s, z, d);
    }
    return o ? $n(l, d, s, u, t.value, e) : l.length ? Promise.all(l).then(() => s) : s;
  };
}), Tr = /* @__PURE__ */ c("$ZodObjectJIT", (e, n) => {
  Pr.init(e, n);
  const t = e._zod.parse, r = Ze(() => kn(n)), o = (v) => {
    const _ = new Xt(["shape", "payload", "ctx"]), T = r.value, Y = (R) => {
      const O = Je(R);
      return `shape[${O}]._zod.run({ value: input[${O}], issues: [] }, ctx)`;
    };
    _.write("const input = payload.value;");
    const H = /* @__PURE__ */ Object.create(null);
    let he = 0;
    for (const R of T.keys)
      H[R] = `key_${he++}`;
    _.write("const newResult = {}");
    for (const R of T.keys) {
      const O = H[R], U = Je(R);
      _.write(`const ${O} = ${Y(R)};`), _.write(`
        if (${O}.issues.length) {
          payload.issues = payload.issues.concat(${O}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${U}, ...iss.path] : [${U}]
          })));
        }
        
        if (${O}.value === undefined) {
          if (${U} in input) {
            newResult[${U}] = undefined;
          }
        } else {
          newResult[${U}] = ${O}.value;
        }
      `);
    }
    _.write("payload.value = newResult;"), _.write("return payload;");
    const me = _.compile();
    return (R, O) => me(v, R, O);
  };
  let i;
  const s = ce, u = !ln.jitless, l = u && Kn.value, h = n.catchall;
  let z;
  e._zod.parse = (v, _) => {
    z ?? (z = r.value);
    const T = v.value;
    return s(T) ? u && l && _?.async === !1 && _.jitless !== !0 ? (i || (i = o(n.shape)), v = i(v, _), h ? $n([], T, v, _, z, e) : v) : t(v, _) : (v.issues.push({
      expected: "object",
      code: "invalid_type",
      input: T,
      inst: e
    }), v);
  };
});
function qe(e, n, t, r) {
  for (const i of e)
    if (i.issues.length === 0)
      return n.value = i.value, n;
  const o = e.filter((i) => !W(i));
  return o.length === 1 ? (n.value = o[0].value, o[0]) : (n.issues.push({
    code: "invalid_union",
    input: n.value,
    inst: t,
    errors: e.map((i) => i.issues.map((s) => L(s, r, F())))
  }), n);
}
const Or = /* @__PURE__ */ c("$ZodUnion", (e, n) => {
  k.init(e, n), m(e._zod, "optin", () => n.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), m(e._zod, "optout", () => n.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), m(e._zod, "values", () => {
    if (n.options.every((o) => o._zod.values))
      return new Set(n.options.flatMap((o) => Array.from(o._zod.values)));
  }), m(e._zod, "pattern", () => {
    if (n.options.every((o) => o._zod.pattern)) {
      const o = n.options.map((i) => i._zod.pattern);
      return new RegExp(`^(${o.map((i) => Ee(i.source)).join("|")})$`);
    }
  });
  const t = n.options.length === 1, r = n.options[0]._zod.run;
  e._zod.parse = (o, i) => {
    if (t)
      return r(o, i);
    let s = !1;
    const u = [];
    for (const d of n.options) {
      const l = d._zod.run({
        value: o.value,
        issues: []
      }, i);
      if (l instanceof Promise)
        u.push(l), s = !0;
      else {
        if (l.issues.length === 0)
          return l;
        u.push(l);
      }
    }
    return s ? Promise.all(u).then((d) => qe(d, o, e, i)) : qe(u, o, e, i);
  };
}), jr = /* @__PURE__ */ c("$ZodIntersection", (e, n) => {
  k.init(e, n), e._zod.parse = (t, r) => {
    const o = t.value, i = n.left._zod.run({ value: o, issues: [] }, r), s = n.right._zod.run({ value: o, issues: [] }, r);
    return i instanceof Promise || s instanceof Promise ? Promise.all([i, s]).then(([d, l]) => Ge(t, d, l)) : Ge(t, i, s);
  };
});
function ke(e, n) {
  if (e === n)
    return { valid: !0, data: e };
  if (e instanceof Date && n instanceof Date && +e == +n)
    return { valid: !0, data: e };
  if (G(e) && G(n)) {
    const t = Object.keys(n), r = Object.keys(e).filter((i) => t.indexOf(i) !== -1), o = { ...e, ...n };
    for (const i of r) {
      const s = ke(e[i], n[i]);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [i, ...s.mergeErrorPath]
        };
      o[i] = s.data;
    }
    return { valid: !0, data: o };
  }
  if (Array.isArray(e) && Array.isArray(n)) {
    if (e.length !== n.length)
      return { valid: !1, mergeErrorPath: [] };
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], i = n[r], s = ke(o, i);
      if (!s.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...s.mergeErrorPath]
        };
      t.push(s.data);
    }
    return { valid: !0, data: t };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function Ge(e, n, t) {
  if (n.issues.length && e.issues.push(...n.issues), t.issues.length && e.issues.push(...t.issues), W(e))
    return e;
  const r = ke(n.value, t.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
const Rr = /* @__PURE__ */ c("$ZodEnum", (e, n) => {
  k.init(e, n);
  const t = qn(n.entries), r = new Set(t);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${t.filter((o) => Xn.has(typeof o)).map((o) => typeof o == "string" ? le(o) : o.toString()).join("|")})$`), e._zod.parse = (o, i) => {
    const s = o.value;
    return r.has(s) || o.issues.push({
      code: "invalid_value",
      values: t,
      input: s,
      inst: e
    }), o;
  };
}), Ar = /* @__PURE__ */ c("$ZodTransform", (e, n) => {
  k.init(e, n), e._zod.parse = (t, r) => {
    if (r.direction === "backward")
      throw new un(e.constructor.name);
    const o = n.transform(t.value, t);
    if (r.async)
      return (o instanceof Promise ? o : Promise.resolve(o)).then((s) => (t.value = s, t));
    if (o instanceof Promise)
      throw new V();
    return t.value = o, t;
  };
});
function Ke(e, n) {
  return e.issues.length && n === void 0 ? { issues: [], value: void 0 } : e;
}
const Sr = /* @__PURE__ */ c("$ZodOptional", (e, n) => {
  k.init(e, n), e._zod.optin = "optional", e._zod.optout = "optional", m(e._zod, "values", () => n.innerType._zod.values ? /* @__PURE__ */ new Set([...n.innerType._zod.values, void 0]) : void 0), m(e._zod, "pattern", () => {
    const t = n.innerType._zod.pattern;
    return t ? new RegExp(`^(${Ee(t.source)})?$`) : void 0;
  }), e._zod.parse = (t, r) => {
    if (n.innerType._zod.optin === "optional") {
      const o = n.innerType._zod.run(t, r);
      return o instanceof Promise ? o.then((i) => Ke(i, t.value)) : Ke(o, t.value);
    }
    return t.value === void 0 ? t : n.innerType._zod.run(t, r);
  };
}), xr = /* @__PURE__ */ c("$ZodNullable", (e, n) => {
  k.init(e, n), m(e._zod, "optin", () => n.innerType._zod.optin), m(e._zod, "optout", () => n.innerType._zod.optout), m(e._zod, "pattern", () => {
    const t = n.innerType._zod.pattern;
    return t ? new RegExp(`^(${Ee(t.source)}|null)$`) : void 0;
  }), m(e._zod, "values", () => n.innerType._zod.values ? /* @__PURE__ */ new Set([...n.innerType._zod.values, null]) : void 0), e._zod.parse = (t, r) => t.value === null ? t : n.innerType._zod.run(t, r);
}), Ir = /* @__PURE__ */ c("$ZodDefault", (e, n) => {
  k.init(e, n), e._zod.optin = "optional", m(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (t, r) => {
    if (r.direction === "backward")
      return n.innerType._zod.run(t, r);
    if (t.value === void 0)
      return t.value = n.defaultValue, t;
    const o = n.innerType._zod.run(t, r);
    return o instanceof Promise ? o.then((i) => Xe(i, n)) : Xe(o, n);
  };
});
function Xe(e, n) {
  return e.value === void 0 && (e.value = n.defaultValue), e;
}
const Cr = /* @__PURE__ */ c("$ZodPrefault", (e, n) => {
  k.init(e, n), e._zod.optin = "optional", m(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (t, r) => (r.direction === "backward" || t.value === void 0 && (t.value = n.defaultValue), n.innerType._zod.run(t, r));
}), Dr = /* @__PURE__ */ c("$ZodNonOptional", (e, n) => {
  k.init(e, n), m(e._zod, "values", () => {
    const t = n.innerType._zod.values;
    return t ? new Set([...t].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (t, r) => {
    const o = n.innerType._zod.run(t, r);
    return o instanceof Promise ? o.then((i) => He(i, e)) : He(o, e);
  };
});
function He(e, n) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: n
  }), e;
}
const Nr = /* @__PURE__ */ c("$ZodCatch", (e, n) => {
  k.init(e, n), m(e._zod, "optin", () => n.innerType._zod.optin), m(e._zod, "optout", () => n.innerType._zod.optout), m(e._zod, "values", () => n.innerType._zod.values), e._zod.parse = (t, r) => {
    if (r.direction === "backward")
      return n.innerType._zod.run(t, r);
    const o = n.innerType._zod.run(t, r);
    return o instanceof Promise ? o.then((i) => (t.value = i.value, i.issues.length && (t.value = n.catchValue({
      ...t,
      error: {
        issues: i.issues.map((s) => L(s, r, F()))
      },
      input: t.value
    }), t.issues = []), t)) : (t.value = o.value, o.issues.length && (t.value = n.catchValue({
      ...t,
      error: {
        issues: o.issues.map((i) => L(i, r, F()))
      },
      input: t.value
    }), t.issues = []), t);
  };
}), Ur = /* @__PURE__ */ c("$ZodPipe", (e, n) => {
  k.init(e, n), m(e._zod, "values", () => n.in._zod.values), m(e._zod, "optin", () => n.in._zod.optin), m(e._zod, "optout", () => n.out._zod.optout), m(e._zod, "propValues", () => n.in._zod.propValues), e._zod.parse = (t, r) => {
    if (r.direction === "backward") {
      const i = n.out._zod.run(t, r);
      return i instanceof Promise ? i.then((s) => re(s, n.in, r)) : re(i, n.in, r);
    }
    const o = n.in._zod.run(t, r);
    return o instanceof Promise ? o.then((i) => re(i, n.out, r)) : re(o, n.out, r);
  };
});
function re(e, n, t) {
  return e.issues.length ? (e.aborted = !0, e) : n._zod.run({ value: e.value, issues: e.issues }, t);
}
const Fr = /* @__PURE__ */ c("$ZodReadonly", (e, n) => {
  k.init(e, n), m(e._zod, "propValues", () => n.innerType._zod.propValues), m(e._zod, "values", () => n.innerType._zod.values), m(e._zod, "optin", () => n.innerType._zod.optin), m(e._zod, "optout", () => n.innerType._zod.optout), e._zod.parse = (t, r) => {
    if (r.direction === "backward")
      return n.innerType._zod.run(t, r);
    const o = n.innerType._zod.run(t, r);
    return o instanceof Promise ? o.then(Qe) : Qe(o);
  };
});
function Qe(e) {
  return e.value = Object.freeze(e.value), e;
}
const Lr = /* @__PURE__ */ c("$ZodCustom", (e, n) => {
  S.init(e, n), k.init(e, n), e._zod.parse = (t, r) => t, e._zod.check = (t) => {
    const r = t.value, o = n.fn(r);
    if (o instanceof Promise)
      return o.then((i) => en(i, t, r, e));
    en(o, t, r, e);
  };
});
function en(e, n, t, r) {
  if (!e) {
    const o = {
      code: "custom",
      input: t,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (o.params = r._zod.def.params), n.issues.push(K(o));
  }
}
class Mr {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(n, ...t) {
    const r = t[0];
    if (this._map.set(n, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, n);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(n) {
    const t = this._map.get(n);
    return t && typeof t == "object" && "id" in t && this._idmap.delete(t.id), this._map.delete(n), this;
  }
  get(n) {
    const t = n._zod.parent;
    if (t) {
      const r = { ...this.get(t) ?? {} };
      delete r.id;
      const o = { ...r, ...this._map.get(n) };
      return Object.keys(o).length ? o : void 0;
    }
    return this._map.get(n);
  }
  has(n) {
    return this._map.has(n);
  }
}
function Wr() {
  return new Mr();
}
const oe = /* @__PURE__ */ Wr();
function Vr(e, n) {
  return new e({
    type: "string",
    ...f(n)
  });
}
function Jr(e, n) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function nn(e, n) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function Yr(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function Br(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...f(n)
  });
}
function qr(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...f(n)
  });
}
function Gr(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...f(n)
  });
}
function Kr(e, n) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function Xr(e, n) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function Hr(e, n) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function Qr(e, n) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function eo(e, n) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function no(e, n) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function to(e, n) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function ro(e, n) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function oo(e, n) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function so(e, n) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function io(e, n) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function co(e, n) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function ao(e, n) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function uo(e, n) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function lo(e, n) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function fo(e, n) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...f(n)
  });
}
function po(e, n) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...f(n)
  });
}
function ho(e, n) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...f(n)
  });
}
function mo(e, n) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...f(n)
  });
}
function _o(e, n) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...f(n)
  });
}
function go(e) {
  return new e({
    type: "unknown"
  });
}
function vo(e, n) {
  return new e({
    type: "never",
    ...f(n)
  });
}
function Zn(e, n) {
  return new Lt({
    check: "max_length",
    ...f(n),
    maximum: e
  });
}
function ue(e, n) {
  return new Mt({
    check: "min_length",
    ...f(n),
    minimum: e
  });
}
function yn(e, n) {
  return new Wt({
    check: "length_equals",
    ...f(n),
    length: e
  });
}
function wo(e, n) {
  return new Vt({
    check: "string_format",
    format: "regex",
    ...f(n),
    pattern: e
  });
}
function bo(e) {
  return new Jt({
    check: "string_format",
    format: "lowercase",
    ...f(e)
  });
}
function zo(e) {
  return new Yt({
    check: "string_format",
    format: "uppercase",
    ...f(e)
  });
}
function ko(e, n) {
  return new Bt({
    check: "string_format",
    format: "includes",
    ...f(n),
    includes: e
  });
}
function $o(e, n) {
  return new qt({
    check: "string_format",
    format: "starts_with",
    ...f(n),
    prefix: e
  });
}
function Zo(e, n) {
  return new Gt({
    check: "string_format",
    format: "ends_with",
    ...f(n),
    suffix: e
  });
}
function X(e) {
  return new Kt({
    check: "overwrite",
    tx: e
  });
}
function yo(e) {
  return X((n) => n.normalize(e));
}
function Eo() {
  return X((e) => e.trim());
}
function Po() {
  return X((e) => e.toLowerCase());
}
function To() {
  return X((e) => e.toUpperCase());
}
function Oo(e, n, t) {
  return new e({
    type: "array",
    element: n,
    // get element() {
    //   return element;
    // },
    ...f(t)
  });
}
function jo(e, n, t) {
  return new e({
    type: "custom",
    check: "custom",
    fn: n,
    ...f(t)
  });
}
function Ro(e) {
  const n = Ao((t) => (t.addIssue = (r) => {
    if (typeof r == "string")
      t.issues.push(K(r, t.value, n._zod.def));
    else {
      const o = r;
      o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = t.value), o.inst ?? (o.inst = n), o.continue ?? (o.continue = !n._zod.def.abort), t.issues.push(K(o));
    }
  }, e(t.value, t)));
  return n;
}
function Ao(e, n) {
  const t = new S({
    check: "custom",
    ...f(n)
  });
  return t._zod.check = e, t;
}
const So = /* @__PURE__ */ c("ZodISODateTime", (e, n) => {
  lr.init(e, n), b.init(e, n);
});
function xo(e) {
  return po(So, e);
}
const Io = /* @__PURE__ */ c("ZodISODate", (e, n) => {
  dr.init(e, n), b.init(e, n);
});
function Co(e) {
  return ho(Io, e);
}
const Do = /* @__PURE__ */ c("ZodISOTime", (e, n) => {
  fr.init(e, n), b.init(e, n);
});
function No(e) {
  return mo(Do, e);
}
const Uo = /* @__PURE__ */ c("ZodISODuration", (e, n) => {
  pr.init(e, n), b.init(e, n);
});
function Fo(e) {
  return _o(Uo, e);
}
const Lo = (e, n) => {
  mn.init(e, n), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (t) => it(e, t)
      // enumerable: false,
    },
    flatten: {
      value: (t) => gn(e, t)
      // enumerable: false,
    },
    addIssue: {
      value: (t) => {
        e.issues.push(t), e.message = JSON.stringify(e.issues, ze, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (t) => {
        e.issues.push(...t), e.message = JSON.stringify(e.issues, ze, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, j = c("ZodError", Lo, {
  Parent: Error
}), Mo = /* @__PURE__ */ Te(j), Wo = /* @__PURE__ */ Oe(j), Vo = /* @__PURE__ */ de(j), Jo = /* @__PURE__ */ fe(j), Yo = /* @__PURE__ */ ut(j), Bo = /* @__PURE__ */ lt(j), qo = /* @__PURE__ */ dt(j), Go = /* @__PURE__ */ ft(j), Ko = /* @__PURE__ */ pt(j), Xo = /* @__PURE__ */ ht(j), Ho = /* @__PURE__ */ mt(j), Qo = /* @__PURE__ */ _t(j), $ = /* @__PURE__ */ c("ZodType", (e, n) => (k.init(e, n), e.def = n, e.type = n.type, Object.defineProperty(e, "_def", { value: n }), e.check = (...t) => e.clone(
  {
    ...n,
    checks: [
      ...n.checks ?? [],
      ...t.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
    ]
  }
  // { parent: true }
), e.clone = (t, r) => N(e, t, r), e.brand = () => e, e.register = ((t, r) => (t.add(e, r), e)), e.parse = (t, r) => Mo(e, t, r, { callee: e.parse }), e.safeParse = (t, r) => Vo(e, t, r), e.parseAsync = async (t, r) => Wo(e, t, r, { callee: e.parseAsync }), e.safeParseAsync = async (t, r) => Jo(e, t, r), e.spa = e.safeParseAsync, e.encode = (t, r) => Yo(e, t, r), e.decode = (t, r) => Bo(e, t, r), e.encodeAsync = async (t, r) => qo(e, t, r), e.decodeAsync = async (t, r) => Go(e, t, r), e.safeEncode = (t, r) => Ko(e, t, r), e.safeDecode = (t, r) => Xo(e, t, r), e.safeEncodeAsync = async (t, r) => Ho(e, t, r), e.safeDecodeAsync = async (t, r) => Qo(e, t, r), e.refine = (t, r) => e.check(Vs(t, r)), e.superRefine = (t) => e.check(Js(t)), e.overwrite = (t) => e.check(X(t)), e.optional = () => on(e), e.nullable = () => sn(e), e.nullish = () => on(sn(e)), e.nonoptional = (t) => Ds(e, t), e.array = () => ks(e), e.or = (t) => Es([e, t]), e.and = (t) => Ts(e, t), e.transform = (t) => cn(e, Rs(t)), e.default = (t) => xs(e, t), e.prefault = (t) => Cs(e, t), e.catch = (t) => Us(e, t), e.pipe = (t) => cn(e, t), e.readonly = () => Ms(e), e.describe = (t) => {
  const r = e.clone();
  return oe.add(r, { description: t }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return oe.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...t) => {
  if (t.length === 0)
    return oe.get(e);
  const r = e.clone();
  return oe.add(r, t[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), En = /* @__PURE__ */ c("_ZodString", (e, n) => {
  je.init(e, n), $.init(e, n);
  const t = e._zod.bag;
  e.format = t.format ?? null, e.minLength = t.minimum ?? null, e.maxLength = t.maximum ?? null, e.regex = (...r) => e.check(wo(...r)), e.includes = (...r) => e.check(ko(...r)), e.startsWith = (...r) => e.check($o(...r)), e.endsWith = (...r) => e.check(Zo(...r)), e.min = (...r) => e.check(ue(...r)), e.max = (...r) => e.check(Zn(...r)), e.length = (...r) => e.check(yn(...r)), e.nonempty = (...r) => e.check(ue(1, ...r)), e.lowercase = (r) => e.check(bo(r)), e.uppercase = (r) => e.check(zo(r)), e.trim = () => e.check(Eo()), e.normalize = (...r) => e.check(yo(...r)), e.toLowerCase = () => e.check(Po()), e.toUpperCase = () => e.check(To());
}), es = /* @__PURE__ */ c("ZodString", (e, n) => {
  je.init(e, n), En.init(e, n), e.email = (t) => e.check(Jr(ns, t)), e.url = (t) => e.check(Kr(ts, t)), e.jwt = (t) => e.check(fo(gs, t)), e.emoji = (t) => e.check(Xr(rs, t)), e.guid = (t) => e.check(nn(tn, t)), e.uuid = (t) => e.check(Yr(ie, t)), e.uuidv4 = (t) => e.check(Br(ie, t)), e.uuidv6 = (t) => e.check(qr(ie, t)), e.uuidv7 = (t) => e.check(Gr(ie, t)), e.nanoid = (t) => e.check(Hr(os, t)), e.guid = (t) => e.check(nn(tn, t)), e.cuid = (t) => e.check(Qr(ss, t)), e.cuid2 = (t) => e.check(eo(is, t)), e.ulid = (t) => e.check(no(cs, t)), e.base64 = (t) => e.check(ao(hs, t)), e.base64url = (t) => e.check(uo(ms, t)), e.xid = (t) => e.check(to(as, t)), e.ksuid = (t) => e.check(ro(us, t)), e.ipv4 = (t) => e.check(oo(ls, t)), e.ipv6 = (t) => e.check(so(ds, t)), e.cidrv4 = (t) => e.check(io(fs, t)), e.cidrv6 = (t) => e.check(co(ps, t)), e.e164 = (t) => e.check(lo(_s, t)), e.datetime = (t) => e.check(xo(t)), e.date = (t) => e.check(Co(t)), e.time = (t) => e.check(No(t)), e.duration = (t) => e.check(Fo(t));
});
function se(e) {
  return Vr(es, e);
}
const b = /* @__PURE__ */ c("ZodStringFormat", (e, n) => {
  g.init(e, n), En.init(e, n);
}), ns = /* @__PURE__ */ c("ZodEmail", (e, n) => {
  nr.init(e, n), b.init(e, n);
}), tn = /* @__PURE__ */ c("ZodGUID", (e, n) => {
  Qt.init(e, n), b.init(e, n);
}), ie = /* @__PURE__ */ c("ZodUUID", (e, n) => {
  er.init(e, n), b.init(e, n);
}), ts = /* @__PURE__ */ c("ZodURL", (e, n) => {
  tr.init(e, n), b.init(e, n);
}), rs = /* @__PURE__ */ c("ZodEmoji", (e, n) => {
  rr.init(e, n), b.init(e, n);
}), os = /* @__PURE__ */ c("ZodNanoID", (e, n) => {
  or.init(e, n), b.init(e, n);
}), ss = /* @__PURE__ */ c("ZodCUID", (e, n) => {
  sr.init(e, n), b.init(e, n);
}), is = /* @__PURE__ */ c("ZodCUID2", (e, n) => {
  ir.init(e, n), b.init(e, n);
}), cs = /* @__PURE__ */ c("ZodULID", (e, n) => {
  cr.init(e, n), b.init(e, n);
}), as = /* @__PURE__ */ c("ZodXID", (e, n) => {
  ar.init(e, n), b.init(e, n);
}), us = /* @__PURE__ */ c("ZodKSUID", (e, n) => {
  ur.init(e, n), b.init(e, n);
}), ls = /* @__PURE__ */ c("ZodIPv4", (e, n) => {
  hr.init(e, n), b.init(e, n);
}), ds = /* @__PURE__ */ c("ZodIPv6", (e, n) => {
  mr.init(e, n), b.init(e, n);
}), fs = /* @__PURE__ */ c("ZodCIDRv4", (e, n) => {
  _r.init(e, n), b.init(e, n);
}), ps = /* @__PURE__ */ c("ZodCIDRv6", (e, n) => {
  gr.init(e, n), b.init(e, n);
}), hs = /* @__PURE__ */ c("ZodBase64", (e, n) => {
  vr.init(e, n), b.init(e, n);
}), ms = /* @__PURE__ */ c("ZodBase64URL", (e, n) => {
  br.init(e, n), b.init(e, n);
}), _s = /* @__PURE__ */ c("ZodE164", (e, n) => {
  zr.init(e, n), b.init(e, n);
}), gs = /* @__PURE__ */ c("ZodJWT", (e, n) => {
  $r.init(e, n), b.init(e, n);
}), vs = /* @__PURE__ */ c("ZodUnknown", (e, n) => {
  Zr.init(e, n), $.init(e, n);
});
function rn() {
  return go(vs);
}
const ws = /* @__PURE__ */ c("ZodNever", (e, n) => {
  yr.init(e, n), $.init(e, n);
});
function bs(e) {
  return vo(ws, e);
}
const zs = /* @__PURE__ */ c("ZodArray", (e, n) => {
  Er.init(e, n), $.init(e, n), e.element = n.element, e.min = (t, r) => e.check(ue(t, r)), e.nonempty = (t) => e.check(ue(1, t)), e.max = (t, r) => e.check(Zn(t, r)), e.length = (t, r) => e.check(yn(t, r)), e.unwrap = () => e.element;
});
function ks(e, n) {
  return Oo(zs, e, n);
}
const $s = /* @__PURE__ */ c("ZodObject", (e, n) => {
  Tr.init(e, n), $.init(e, n), m(e, "shape", () => n.shape), e.keyof = () => Os(Object.keys(e._zod.def.shape)), e.catchall = (t) => e.clone({ ...e._zod.def, catchall: t }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: rn() }), e.loose = () => e.clone({ ...e._zod.def, catchall: rn() }), e.strict = () => e.clone({ ...e._zod.def, catchall: bs() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (t) => nt(e, t), e.safeExtend = (t) => tt(e, t), e.merge = (t) => rt(e, t), e.pick = (t) => Qn(e, t), e.omit = (t) => et(e, t), e.partial = (...t) => ot(Pn, e, t[0]), e.required = (...t) => st(Tn, e, t[0]);
});
function Zs(e, n) {
  const t = {
    type: "object",
    get shape() {
      return D(this, "shape", e ? Gn(e) : {}), this.shape;
    },
    ...f(n)
  };
  return new $s(t);
}
const ys = /* @__PURE__ */ c("ZodUnion", (e, n) => {
  Or.init(e, n), $.init(e, n), e.options = n.options;
});
function Es(e, n) {
  return new ys({
    type: "union",
    options: e,
    ...f(n)
  });
}
const Ps = /* @__PURE__ */ c("ZodIntersection", (e, n) => {
  jr.init(e, n), $.init(e, n);
});
function Ts(e, n) {
  return new Ps({
    type: "intersection",
    left: e,
    right: n
  });
}
const $e = /* @__PURE__ */ c("ZodEnum", (e, n) => {
  Rr.init(e, n), $.init(e, n), e.enum = n.entries, e.options = Object.values(n.entries);
  const t = new Set(Object.keys(n.entries));
  e.extract = (r, o) => {
    const i = {};
    for (const s of r)
      if (t.has(s))
        i[s] = n.entries[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new $e({
      ...n,
      checks: [],
      ...f(o),
      entries: i
    });
  }, e.exclude = (r, o) => {
    const i = { ...n.entries };
    for (const s of r)
      if (t.has(s))
        delete i[s];
      else
        throw new Error(`Key ${s} not found in enum`);
    return new $e({
      ...n,
      checks: [],
      ...f(o),
      entries: i
    });
  };
});
function Os(e, n) {
  const t = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new $e({
    type: "enum",
    entries: t,
    ...f(n)
  });
}
const js = /* @__PURE__ */ c("ZodTransform", (e, n) => {
  Ar.init(e, n), $.init(e, n), e._zod.parse = (t, r) => {
    if (r.direction === "backward")
      throw new un(e.constructor.name);
    t.addIssue = (i) => {
      if (typeof i == "string")
        t.issues.push(K(i, t.value, n));
      else {
        const s = i;
        s.fatal && (s.continue = !1), s.code ?? (s.code = "custom"), s.input ?? (s.input = t.value), s.inst ?? (s.inst = e), t.issues.push(K(s));
      }
    };
    const o = n.transform(t.value, t);
    return o instanceof Promise ? o.then((i) => (t.value = i, t)) : (t.value = o, t);
  };
});
function Rs(e) {
  return new js({
    type: "transform",
    transform: e
  });
}
const Pn = /* @__PURE__ */ c("ZodOptional", (e, n) => {
  Sr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType;
});
function on(e) {
  return new Pn({
    type: "optional",
    innerType: e
  });
}
const As = /* @__PURE__ */ c("ZodNullable", (e, n) => {
  xr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType;
});
function sn(e) {
  return new As({
    type: "nullable",
    innerType: e
  });
}
const Ss = /* @__PURE__ */ c("ZodDefault", (e, n) => {
  Ir.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function xs(e, n) {
  return new Ss({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof n == "function" ? n() : fn(n);
    }
  });
}
const Is = /* @__PURE__ */ c("ZodPrefault", (e, n) => {
  Cr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType;
});
function Cs(e, n) {
  return new Is({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof n == "function" ? n() : fn(n);
    }
  });
}
const Tn = /* @__PURE__ */ c("ZodNonOptional", (e, n) => {
  Dr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType;
});
function Ds(e, n) {
  return new Tn({
    type: "nonoptional",
    innerType: e,
    ...f(n)
  });
}
const Ns = /* @__PURE__ */ c("ZodCatch", (e, n) => {
  Nr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Us(e, n) {
  return new Ns({
    type: "catch",
    innerType: e,
    catchValue: typeof n == "function" ? n : () => n
  });
}
const Fs = /* @__PURE__ */ c("ZodPipe", (e, n) => {
  Ur.init(e, n), $.init(e, n), e.in = n.in, e.out = n.out;
});
function cn(e, n) {
  return new Fs({
    type: "pipe",
    in: e,
    out: n
    // ...util.normalizeParams(params),
  });
}
const Ls = /* @__PURE__ */ c("ZodReadonly", (e, n) => {
  Fr.init(e, n), $.init(e, n), e.unwrap = () => e._zod.def.innerType;
});
function Ms(e) {
  return new Ls({
    type: "readonly",
    innerType: e
  });
}
const Ws = /* @__PURE__ */ c("ZodCustom", (e, n) => {
  Lr.init(e, n), $.init(e, n);
});
function Vs(e, n = {}) {
  return jo(Ws, e, n);
}
function Js(e) {
  return Ro(e);
}
const Ys = Zs({
  [E.firstName]: se().min(1, "First name is required"),
  [E.lastName]: se().min(1, "Last name is required"),
  [E.password]: se().min(5, "Password needs to be at least 5 characters"),
  [E.passwordCheck]: se()
}).refine(
  (e) => e[E.password] === e[E.passwordCheck],
  {
    message: "Passwords do not match",
    path: [E.passwordCheck]
  }
), Bs = ({ formData: e }) => Ys.safeParse(e), qs = async ({
  e,
  action: n,
  formData: t,
  setError: r
}) => {
  e.preventDefault();
  const o = Bs({ formData: t });
  if (!o.success) {
    const i = {}, u = gn(o.error).fieldErrors ?? {};
    for (const [d, l] of Object.entries(u))
      l.length > 0 && (i[d] = l[0]);
    r(i);
    return;
  }
  r({}), await fetch(n, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(o.data)
  });
}, Hs = ({
  variant: e = an.FullName,
  action: n
}) => {
  const [t, r] = Ne({
    [E.firstName]: "",
    [E.lastName]: "",
    [E.password]: "",
    [E.passwordCheck]: ""
  }), [o, i] = Ne({});
  return /* @__PURE__ */ P.jsxs(
    Yn,
    {
      action: n,
      method: "POST",
      onSubmit: (s) => qs({ e: s, action: n, formData: t, setError: i }),
      children: [
        /* @__PURE__ */ P.jsxs(We, { children: [
          /* @__PURE__ */ P.jsx(
            ee,
            {
              label: "First Name",
              name: E.firstName,
              value: t.firstName,
              onChange: (s) => ne({ e: s, setState: r }),
              errorMessage: o.firstName
            }
          ),
          /* @__PURE__ */ P.jsx(
            ee,
            {
              label: "Last Name",
              name: E.lastName,
              value: t.lastName,
              onChange: (s) => ne({ e: s, setState: r }),
              errorMessage: o.lastName
            }
          )
        ] }),
        /* @__PURE__ */ P.jsxs(We, { children: [
          /* @__PURE__ */ P.jsx(
            ee,
            {
              type: "password",
              label: "Password",
              name: E.password,
              value: t.password,
              onChange: (s) => ne({ e: s, setState: r }),
              errorMessage: o.password
            }
          ),
          /* @__PURE__ */ P.jsx(
            ee,
            {
              type: "password",
              label: "Re-Type Password",
              name: E.passwordCheck,
              value: t.passwordCheck,
              onChange: (s) => ne({ e: s, setState: r }),
              errorMessage: o.passwordCheck
            }
          )
        ] }),
        /* @__PURE__ */ P.jsx(Bn, { text: "Create Account", type: "submit" })
      ]
    }
  );
};
export {
  Fn as Button,
  Xs as Cascade,
  ee as Input,
  Hs as SignUp
};
